#ifndef FUNC_H
#define FUNC_H

#include <cstdlib>
#include "type.h"


// Crash program for owns asserts
// --------------------------------------------------------------------------------------------------
#define CRASH_PROGRAM(reason) \
 printf ("ERROR: crash program in %s:%d\n" \
         "Reason: %s\n", \
         __FILE__, __LINE__, reason); \
 exit (1);
// --------------------------------------------------------------------------------------------------


// Exit functions with auto print error
// --------------------------------------------------------------------------------------------------
#define EXIT_FUNC(reason, return_value) \
 printf ("ERROR in \"%s:%d\": %s\n", __FILE__, __LINE__, reason); \
 return return_value;
// --------------------------------------------------------------------------------------------------


// Own assert for objects
// --------------------------------------------------------------------------------------------------
#define ASSERT_OBJECT(object) \
 if (object.name == NULL) \
 { \
     CRASH_PROGRAM("BAD_OBJECT"); \
 }
// --------------------------------------------------------------------------------------------------


// Вывод текста на главный экран
// --------------------------------------------------------------------------------------------------
#define PRINT_TEXT(__display, __text) \
 push_text (__display, __text); \
 __display->cur_frame.amount_but = 0; \
 renew_display (__display); \
 SDL_Delay (STANDARD_SLEEP * 7);
// --------------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция заполнения структуры дерева
 * @param [in] tree Адрес структуры дерева
*/
// --------------------------------------------------------------------------------------------------
int create_tree (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция обработки ивентов, полученных от пользователя
*/
// --------------------------------------------------------------------------------------------------
int akinator ();
// --------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------
/**
 * @brief Функция поиска объекта в базе данных
 * @param [in] node Указатель на узел
 * @param [in] object Объект, который и надо найти
 * @return node_t* (указатель на узел) - если узел найдет, иначе -> NULL
 * @note Может быть как рекурсивная, так и стековая (#define STACK_FUNC)
*/
// ----------------------------------------------------------------------------------------------------
node_t* find_node (node_t* node,
                   obj_t object);
// ----------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция получения узла по объекту, полученному от пользователя
 * @param [in] tree Указатель на структуру дерева
 * @return node_t* (если объект нашелся), иначе -> NULL
*/
// --------------------------------------------------------------------------------------------------
node_t* get_user_node (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция записи изображения в текущий кадр
 * @param [in] display Указатель на структуру дисплея
 * @param [in] object Переданный объект
*/
// --------------------------------------------------------------------------------------------------
int push_image_object (display_t* display,
                       obj_t object);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция удаления текстуры объекта из окна
 * @param [in] display Указатель на структуру дисплея
*/
// --------------------------------------------------------------------------------------------------
int pop_image_object (display_t* display);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция удаления всего дерева
 * @param [in] tree Указатель на структуру дерева
*/
// --------------------------------------------------------------------------------------------------
int delete_tree (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция удаления элемента
 * @param [in] node Указатель на текущий удаляемый узел
 * @return 0
 * @note Может быть как рекурсивная, так и стековая (#define STACK_FUNC)
*/
// --------------------------------------------------------------------------------------------------
int delete_node (node_t* node);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция описания объекта
 * @param [in] tree Указатель на структуру дерева
*/
// --------------------------------------------------------------------------------------------------
int desc_object (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция сравнения объектов, реализованная на и цикле со стеком, и на обычном динамическом массиве
 * @param [in] tree Указатель на структуру дерева
 * @note Тип обработки данных настраивается через STACK_FUNC (если объявлен, то используется стек, иначе -> динамический массив)
*/
// --------------------------------------------------------------------------------------------------
int compare_objects (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция отгадывания пользовательского объекта и, при необходимости, добавления его в базу данных
 * @param [in] tree Указатель на структуру дерева
*/
// --------------------------------------------------------------------------------------------------
int guess_object (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------
/**
 * @brief Функция получения пользовательского объекта и сохранение его в динамическую память
 * @param [in] display Указатель на структуру дисплея
 * @return obj_t - пользовательский объект
 * @note Сохраняет в динамическую память -> необходимо с дальнейшем будет самому освободить
*/
// ----------------------------------------------------------------------------------------------------
obj_t get_user_object (display_t* display);
// ----------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------
/**
 * @brief Функция проверки корректности пользовательской строки на предмет наличия отрицания
 * @param [in] object Пользовательский объект, направленный на проверку
 * @return 0 - если корректный ввод, иначе -1
*/
// ----------------------------------------------------------------------------------------------------
int check_user_object (obj_t object);
// ----------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Создание узла и добавление связей
 *
 * @param [in] root Родительский корень
 * @param [in] side Сторона, куда нужно добавлять новый элемент
 * @param [in] object Добавляемый объект
 * @return node_t* Указатель на новый узел
 */
// --------------------------------------------------------------------------------------------------
node_t* create_node (node_t* root,
                     SIDES side,
                     obj_t object);
// --------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция создания адреса аудио файла для его расположения в стандартной директории
 * @param [in] buffer Указатель на адрес
 * @param [in] name_obj Имя объекта -> Имя файла
*/
// --------------------------------------------------------------------------------------------------
int create_adr_audio (char* buffer,
                      const char* name_obj);
// --------------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция сохранения базы данных либо в стандартную директорию, либо в пользовательский файл
 * @param [in] tree Указатель на структуру дерева
 * @return 0
*/
// --------------------------------------------------------------------------------------------------
int save_data (tree_t* tree);
// --------------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------------
/**
 * @brief Рекурсивная функция, сохраняющая узел в файл
 * @param [in] node Узел, который будет сохраняться
 * @param [in] file Указатель на файл, куда будет записываться база данных
 * @return 0
*/
// ----------------------------------------------------------------------------------------------------
int save_node (node_t* node,
               FILE* file);
// ----------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция, загружающая базу данных из выбранной пользователем директории, либо из введенного файла
 * @param [in] tree Дерево, в которое загружается база данных, предварительно освобождая его
 * @return 1
 */
// --------------------------------------------------------------------------------------------------
int import_data (tree_t* tree);
// --------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------
/**
 * @brief Рекурсивная функция создания узла по буферу
 *
 * @param [in] root Родительский корень
 * @param [in] cur_char Указатель на адрес буфера
 * @param [in] size_tree Указатель на размер дерева
 * @return node_t* Указатель на новый узел
 */
// ----------------------------------------------------------------------------------------------------
node_t* upload_node (node_t* root,
                     char** cur_char,
                     int* size_tree);
// ----------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------
/**
 * @brief Функция скипа cur_char до символа, замена его на '\0' и перевод cur_char на следующий
 * @param [in] cur_pose Указатель на адрес хранения текущего символа
 * @param [in] symbol Символ, который будет заменяться на '\0'
*/
// ----------------------------------------------------------------------------------------------------
int skip_after_symbol (char** cur_pose,
                       int symbol);
// ----------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------
/**
 * @brief Функция скипа всего ненужного синтаксиса, указанного в SYNTAX_VOID
 * @param [in] Указатель на адрес хранения текущего символа
*/
// ----------------------------------------------------------------------------------------------------
int skip_void (char** cur_pose);
// ----------------------------------------------------------------------------------------------------




// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция дампа всего дерева
 * @param [in] tree Указатель на структуру всего дерева
 * @param [in] reason Причина вызова дампа
 * @return 0
*/
// -------------------------------------------------------------------------------------------------------
int dump_tree (tree_t* tree,
               const char* reason);
// -------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция записи дампа в html файл
 * @param [in] tree Указатель на структуру дерева
 * @param [in] address Имя html файла
 * @param [in] reason Причина дампа
 * @return 0 (если все нормально), иначе -1
*/
// -------------------------------------------------------------------------------------------------------
int create_html (tree_t* tree,
                 const char* address,
                 const char* reason);
// -------------------------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция создания графа по дереву
 * @param [in] tree Указатель на причину дампа
 * @return 0 (если не было ошибок), иначе -> -1
*/
// -------------------------------------------------------------------------------------------------------
int create_graph (tree_t* tree);
// -------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция создания графа для debug
 * @param [in] root Узел, с которого строится граф
 * @return 0 (если не было ошибок), иначе -> -1
 * @note Граф сохраняется в свою директорию ADDRESS_DUMP_DEBUG
*/
// -------------------------------------------------------------------------------------------------------
int debug_graph (node_t* root);
// -------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Рекурсивная функция создания блоков графа
 * @param [in] node Указатель на текущий узел
 * @param [in] file Указатель на dot файл
 * @return 0
*/
// -------------------------------------------------------------------------------------------------------
int create_block (node_t* node,
                  FILE* file);
// -------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Рекурсивная функция создания связей между блоками
 * @param [in] node Указатель на текущий узел
 * @param [in] file Указатель на dot файл
 * @return 0
*/
// -------------------------------------------------------------------------------------------------------
int create_line (node_t* node,
                 FILE* file);
// -------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция создания html файла для debug
 * @param [in] root Указатель на родительский элемент
 * @param [in] reason Причина дампа
 * @param [in] add_string Дополнительная строка, которая выводится в dump
*/
// -------------------------------------------------------------------------------------------------------
int debug_html (node_t* root,
                const char* reason,
                const char* add_string);
// -------------------------------------------------------------------------------------------------------




// --------------------------------------------------------------------------------------------------
/**
 * @brief Хеш-функция
 * @param [in] string Строка, которая преобразуется в хеш
 * @return Хеш строки
*/
// --------------------------------------------------------------------------------------------------
int get_hash (const char* string);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция, превращающая число в строку его десятичной записи
 * @param [in] value Число, которое надо превратить
 * @return Указатель на динамическую память, где храниться строка
*/
// --------------------------------------------------------------------------------------------------
char* int_to_char (int value);
// --------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция, находящая размер файла в байтах по его имени
 * @param [in] name_file Имя файла
 * @return Размер файла
*/
// -------------------------------------------------------------------------------------------------------
size_t file_size_check (const char* name_file);
// -------------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция нахождения размера имени объекта
 * @param [in] object Объект, размер имени которого нужен
*/
// --------------------------------------------------------------------------------------------------
size_t get_len_name (obj_t object);
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция нахождения нужной директории для дампов этого запуска
 * @return Номер директории в стандартной папку дампов
*/
// --------------------------------------------------------------------------------------------------
int find_number_dump ();
// --------------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------------
/**
 * @brief Функция создания адреса файла в папке
 * @param [in] address_dir Адрес стандартной директории, в которой находится файл
 * @param [in] number_dir Номер нужной директории в стандартной
 * @param [in] address_file Адрес файла в нужной директории
 * @param [in] string Строка, куда будет записан адрес
*/
// --------------------------------------------------------------------------------------------------
int make_dir_address (const char* address_dir,
                      const int number_dir,
                      const char* address_file,
                      char* string);
// --------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция очистки и начального заполнения html файла
 * @param [in] address_html Адрес html файла
*/
// -------------------------------------------------------------------------------------------------------
int clean_html (const char* address_html);
// -------------------------------------------------------------------------------------------------------


// -------------------------------------------------------------------------------------------------------
/**
 * @brief Функция очистки выбранной директории
 * @param [in] address_dir Адрес выбранной директории
*/
// -------------------------------------------------------------------------------------------------------
int clean_dir (const char* address_dir);
// -------------------------------------------------------------------------------------------------------


#endif // FUNC_H
